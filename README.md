å…¬å¼æ˜¾ç¤ºä¸å‡ºæ¥ï¼Œè¯¦æƒ…è¯·çœ‹https://zhuanlan.zhihu.com/p/632134425

å¤§æ°”æ•£å°„æ•ˆæœå¯¹æ¸¸æˆç”»è´¨æå‡æ¥è¯´å·¨å¤§ï¼Œæœ¬æ–‡ä¸»è¦ä»ä»£ç å±‚é¢è®²è§£ä¸‹å¤§æ°”æ•£å°„

## å•æ¬¡æ•£å°„

![img](https://picx.zhimg.com/80/v2-9bcabe275d66d51134fd225c4453d92c_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

è·¯å¾„ AB è§‚å¯Ÿå¤§æ°”ï¼Œå¹¶ä¸”æ±‚è§£ B ç‚¹çš„å¤§æ°”é¢œè‰²ï¼Œå…‰çº¿åœ¨å¤§æ°”ä¸­åªå‘ç”Ÿä¸€æ¬¡æ•£å°„ï¼Œæ•£å°„ç‚¹ä¸º P

é˜³å…‰è¿›å…¥å¤§æ°”å±‚CPå¼€å§‹è¡°å‡ï¼Œåœ¨Pç‚¹å‘ç”Ÿæ•£å°„ï¼Œç„¶åPAè¡°å‡è¿›å…¥Aç‚¹ç›¸æœº

ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½(ï¿½,ï¿½,â„)ï¿½(ï¿½ï¿½) 

ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½(ï¿½,ï¿½,â„)ï¿½(ï¿½ï¿½) 

Tè¡¨ç¤ºè¡°å‡ç³»æ•° è¡¨ç¤ºæŸæ®µè·¯å¾„ä¸Šå…‰ç…§çš„è¡°å‡ç¨‹åº¦

Sè¡¨ç¤ºæ•£å°„ç³»æ•° è¡¨ç¤ºæœ‰å¤šå°‘å…‰æ•£å°„çš„è§’åº¦ä¸ºÎ¸ï¼ŒÎ»ä¸ºæ³¢é•¿ï¼Œh

![img](https://picx.zhimg.com/80/v2-e02a5800ebfe6a25b07386bace6ab65a_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

å®é™…ä¸Šåœ¨è·¯å¾„ AB(ä¹Ÿå¯èƒ½æ˜¯æ–œçš„ä¸€æ¡å°„çº¿) ä¸Šæœ‰æ— æ•°ä¸ª P ç‚¹ï¼Œå› æ­¤æœ€ç»ˆæ±‚è§£æ˜¯å¯¹ AB è·¯å¾„ä¸Šæ¯ä¸€ä¸ªç‚¹çš„å…‰ç…§è´¡çŒ®è¿›è¡Œç´¯åŠ  (æ±‚ç§¯åˆ†ï¼Œä¸åŒé«˜åº¦ä¸åŒå¯†åº¦)

âˆ«ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½)ï¿½(ï¿½,ï¿½,â„)ï¿½(ï¿½ï¿½)ï¿½ï¿½

![img](https://pic1.zhimg.com/80/v2-bb74f1805f00ed78d65febe91add0e3d_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

## æ•£å°„ç±»å‹åˆ†2ç§

### Rayleigh Scattering

å¤§å°è¿œå°äºå…‰çº¿æ³¢é•¿çš„ç²’å­ï¼Œç”±äºç²’å­æ¯”æ³¢é•¿è¿˜è¦å°å¾ˆå¤šï¼Œæ‰€ä»¥å…‰çš„æ³¢é•¿ä¹Ÿä¼šå½±å“æ•£å°„ç¨‹åº¦

### Mie Scattering

å¤§å°è¿œå¤§äºå…‰çº¿æ³¢é•¿çš„ç²’å­ï¼Œç”±äºå…‰çš„æ³¢é•¿ç›¸è¾ƒäºè¿™äº›ç²’å­å¤§å°æ¥è¯´æ˜¯å¯ä»¥å¿½ç•¥çš„ï¼Œæ‰€ä»¥è®¤ä¸ºMie Scatteringå’Œå…‰çº¿æ³¢é•¿æ— å…³ï¼ŒMie Scatteringæ˜¯å¤ªé˜³å‘¨å›´å…‰æ™•çš„ä¸»è¦æˆå› 

## æ•£å°„æ–¹ç¨‹

 

Î»å…‰çš„æ³¢é•¿(R680 G550 B440nm)ï¼ŒÎ¸æ•£å°„è§’åº¦ï¼Œhé«˜åº¦ï¼Œnç©ºæ°”çš„æŠ˜å°„ç‡ï¼ŒNä¸€ä¸ªå¸¸æ•°è¡¨ç¤ºå¤§æ°”åšåº¦ï¼Œå¤§æ°”å¯†åº¦Ï(h)å¯†åº¦æ¯”ï¼Œåœ¨æµ·å¹³é¢ä¸º1ï¼Œéšé«˜åº¦å‘ˆæŒ‡æ•°ä¸‹é™

![img](https://picx.zhimg.com/80/v2-7821323ab66d8d7e6bc9d2aa51c25fff_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

æ•£å°„æ–¹ç¨‹ä¸»è¦åˆ†ä¸ºï¼Œ1æ•£å°„ç³»æ•°ï¼Œ2ç›¸ä½å‡½æ•°ï¼Œ3å¤§æ°”å¯†åº¦æ¯”

### 1 æ•£å°„ç³»æ•°

 

 

åœ¨æµ·å¹³é¢ä¸Šï¼Œæ˜¯ä¸€ä¸ªå¸¸æ•°

Rayleigh 0.005802f, 0.013558f, 0.033100f

Mie æ¥è¯´ 0.003996f, 0.003996f, 0.003996f

### 2 ç›¸ä½å‡½æ•°

 

![img](https://picx.zhimg.com/80/v2-c9958ed39a8b2844f09e8a99586ebf63_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

### 3 å¤§æ°”å¯†åº¦æ¯”

 

Rayleigh æ¥è¯´ï¼ŒH= 8500ç±³

Mie æ¥è¯´ï¼ŒH = 1200ç±³

é¢œè‰²æ¥è¡¨ç¤ºRayleighçš„æ•£å°„

![img](https://pic1.zhimg.com/80/v2-216a8b568e6ab2849961da5ef5d54a01_720w.png?source=d16d100b)



ç¼–è¾‘

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

### Absorption

é™¤äº†å‘ç”Ÿæ•£å°„ï¼Œå¤§æ°”ä¸­è¿˜æœ‰è‡­æ°§å’Œç”²çƒ·å¸æ”¶

è‡­æ°§(O3)è‡­æ°§ä¸»è¦å¸æ”¶çŸ­æ³¢ç´«å¤–çº¿

ç”²çƒ·ï¼ˆCH4ï¼‰ç”²çƒ·æ˜¯ä¸€ç§å¸æ”¶çº¢å¤–å…‰è€Œåå°„è“å…‰çš„æ°”ä½“

![img](https://picx.zhimg.com/80/v2-015ffede7227bb535b9973668a2778af_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

Ragleighæ²¡æœ‰å¸æ”¶

ç”¨é¢œè‰²æ¥è¡¨ç¤ºä¸‹Absorption

![img](https://picx.zhimg.com/80/v2-9b34c5b22d43da6b31f2cb3be4e0bd0f_720w.png?source=d16d100b)



ç¼–è¾‘

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

å…¬å¼è¡¨

![img](https://pic1.zhimg.com/80/v2-e0145bddb302176a7bee03aa00d80eff_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

ä¼ªä»£ç 

```
Function Transmittance(float3 A, float3 B)
{
    float   SAMPLE=64//é‡‡æ ·æ¬¡æ•°
    float   distance=length(A,B)
    float3  dir=B-A
    float   ds=distance/SAMPLE
    float3  p = A + (dir * ds) * 0.5;
    float3 result=0
    //ç®—ç§¯åˆ†
    for(int i=0; i<SAMPLE; i++)
    {
        float h = length(p)
        float3 extinctionMie = MieExtinction(h);
        float3 extinctionRay = RayleighCoefficient(h)
        float3 extinctionOzo = OzoneAbsorption(h)
        result += (extinctionMie + extinctionRay + extinctionOzo)*ds
    }
    return exp(-result)
}
float3 eyePos
float3 viewDir
float3 lightDir
float3 P = eyePos + (viewDir * ds) * 0.5
float  cosâ¡ğœƒ = dot(lightDir, viewDir)
float3 RayleighScattering = RayleighCoefficient(h) * RayleiPhase(cosâ¡ğœƒ)
float3 MieScattering = MieCoefficient(h) * MiePhase(cosâ¡ğœƒ)
Single Scattering = Transmittance(P,lightDir) *(RayleighScattering+MieScattering) * Transmittance(eyePos,P)
```

## **Multi Scattering**

### å¾®åˆ†ç«‹ä½“è§’

åœ¨è®²è§£å¤šæ¬¡æ•£å°„ï¼Œéœ€è¦å¯¹å¾®åˆ†ç«‹ä½“è§’æœ‰ä¸€ä¸ªäº†è§£ï¼Œå¥½ç†è§£èƒ½é‡å®ˆæ’

![img](https://pica.zhimg.com/80/v2-e8c445d618739cfd6ddb9e0f4f874151_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

![img](https://picx.zhimg.com/80/v2-5c4fec28da93bad4f53a3196ef5fff2d_720w.png?source=d16d100b)



ç¼–è¾‘

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

æ•´ä¸ªçƒä½“çš„ç«‹ä½“è§’å°±æ˜¯4Ï€

å¾®åˆ†ç«‹ä½“è§’å°±æ˜¯A/(r*r) é¢ç§¯é™¤ä»¥åŠå¾„çš„å¹³æ–¹

### **è¾å°„åº¦é‡å­¦**

![img](https://picx.zhimg.com/80/v2-0d8b7faf475c44bffc675e42434cf908_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

è¾å°„å¼ºåº¦(Radiant Intensity) æ˜¯ä»å…‰æºå‡ºå‘ï¼Œæ¯å•ä½ç«‹ä½“è§’ä¸Šçš„åŠŸç‡ï¼ˆäº®åº¦ï¼‰

è¾ç…§åº¦(Irradiance) æ˜¯å…¥å°„**æŠ•å½±**åˆ°å•ä½é¢ç§¯ä¸Šçš„åŠŸç‡ï¼ˆå…‰ç…§ã€è¾å°„é€šé‡ï¼‰

è¾å°„(Radiance) æ˜¯æè¿°å…‰åœ¨ç¯å¢ƒä¸­åˆ†å¸ƒçš„åŸºæœ¬åœºé‡ï¼Œè¾å°„æè¿° **æ¯å•ä½ç«‹ä½“è§’ã€æ¯å•ä½å‚ç›´é¢ç§¯çš„åŠŸç‡**

æ€»ç»“ï¼šå‡è®¾ä»å…‰æºæ€»çš„è¾å°„å¼ºåº¦**Radiant Intensity**ä¸º1ï¼ŒåŠå¾„ä¸º2çš„ç«‹ä½“è§’çš„è¾ç…§åº¦**Irradiance**å°±æ˜¯1/(4Ï€2^2)ï¼Œ

è¾å°„Radianceå°±æ˜¯1/(4Ï€2^2)*dw*,æ¯ä¸ªå¾®åˆ†ç«‹ä½“è§’å¯ä»¥æ¥å—åˆ°çš„èƒ½é‡

æ¯”å¦‚æˆ‘ä»¬è¦ç®—ä¸€ä¸ªåŠçƒé¢èƒ½æ¥å—å¤šå°‘å…‰ç…§ï¼Œç›´æ¥åšä¸€ä¸ªç§¯åˆ†ï¼Œå°±å¯ä»¥ç›´æ¥ç®—å‡ºæ¥ï¼Œè¿™æ ·è®¡ç®—çš„å…‰ç…§èƒ½é‡å®ˆæ’

![img](https://pica.zhimg.com/80/v2-0297d007832de337f9431ccc90cfd3d7_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

### å¤šæ•£æ¬¡å°„çš„ç»è¿‡

![img](https://picx.zhimg.com/80/v2-7cf541b4db6114f6b73717189886ea74_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

æ€»çš„æ¥è¯´ï¼Œaç®—å‡ºå•æ¬¡æ•£å°„ï¼ŒbåŠ ä¸Šåœ°é¢çš„åå°„ï¼Œcåšä¸€ä¸ªçƒé¢çš„ç§¯åˆ†ï¼ŒdæŠŠæ•´ä¸ªè§†çº¿è·¯å¾„åšä¸€ä¸ªç§¯åˆ†ï¼Œæ±‚å‡ºæœ‰å¤šå°‘å…‰å¯ä»¥åˆ°çœ¼ç›é‡Œ

## Bruneton2017

å‚è€ƒäº†Brunetonçš„ä»£ç ï¼ŒåŠŸèƒ½å¾ˆå…¨ï¼Œä»…éœ€è‡ªå·±ä¿®æ”¹é‡‡æ ·shadow

```
ä¼ªä»£ç 
ComputeTransmittanceLUT()
ComputeDirectIrradianceLUT()
ComputeSingleScatteringLUT()
for (uint order = 2; order <= numScatteringOrders; order++) {
	ComputeScatteringDensity()// order>=2è®¡ç®—é—´æ¥å…‰ç…§ï¼Œ order>2åœ°çƒè¡¨é¢åå°„å…‰
	ComputeIndirectIrradiance()//åœ°çƒè¡¨é¢åå°„å…‰
	ComputeMultipleScattering()//PAç§¯åˆ†
}
```

ä¼˜ç‚¹å°±æ˜¯ä¸€æ¬¡è®¡ç®—å®Œå„ä¸ªæ–¹å‘r(é«˜åº¦), mu(è§†è§’å¤©é¡¶è§’), mu_s(å¤ªé˜³å¤©é¡¶è§’), nu(è§†çº¿å’Œå¤ªé˜³çš„å¤¹è§’)

å¹¶ä¸”æŠŠmu_så’Œnuå‹ç¼©åˆ°ä¸€ä¸ªå˜é‡é‡Œé¢

```
Number frag_coord_nu = floor(frag_coord.x / Number(SCATTERING_TEXTURE_MU_S_SIZE));
Number frag_coord_mu_s = fmod(frag_coord.x, Number(SCATTERING_TEXTURE_MU_S_SIZE))
```

ä¿å­˜ç»“æœåˆ°ä¸€ä¸ª3DTextureï¼Œç›´æ¥é‡‡æ ·å°±è¡Œäº†

ç¼ºç‚¹å°±æ˜¯å¦‚æœéœ€è¦ä¿®æ”¹é»˜è®¤å‚æ•°ï¼Œå°±è¦é‡æ–°æ¸²æŸ“ä¸€æ¬¡ï¼Œæ¶ˆè€—å·¨å¤§ï¼ŒPCéƒ½å¡ï¼Œç§»åŠ¨ç«¯æ›´å—ä¸äº†

## UnrealEngineSkyAtmosphereçš„LUTé¢„å¤„ç†

ä¸»è¦éœ€è¦è®¡ç®—4ä¸ªLUT

TransmittanceLUT MultipleScatteringLUT  Sky-ViewLUT AerialPerspectiveLUT

### TransmittanceLUT 

uv åˆ†åˆ«è¡¨ç¤º **é«˜åº¦ï¼ˆrï¼‰**å’Œ**è§†è§’**å¤©é¡¶è§’ï¼ˆmuï¼‰

```
[numthreads(8, 8, 1)]
void IntergalTransmittanceLUT(uint3 id: SV_DispatchThreadID)
{
    float2 pixPos = id.xy + 0.5f;

    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    // Compute camera position from LUT coords
    float2 uv = (pixPos) / float2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
    float viewHeight;
    float viewZenithCosAngle;
    UvToLutTransmittanceParams(Atmosphere, viewHeight, viewZenithCosAngle, uv);

    //  A few extra needed constants
    float3 WorldPos = float3(0.0f, viewHeight, 0.0f);
    float3 WorldDir = float3(sqrt(1.0 - viewZenithCosAngle * viewZenithCosAngle), viewZenithCosAngle, 0.0f);

    const bool ground = false;
    const float SampleCountIni = 40.0f; // Can go a low as 10 sample but energy lost starts to be visible.
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = false;
    float3 transmittance = exp(-IntegrateScatteredLuminance(uv, WorldPos, WorldDir, sun_direction, Atmosphere,
                                                            ground, SampleCountIni, DepthBufferValue,
                                                            VariableSampleCount, MieRayPhase).OpticalDepth);

    _TransmittanceLUT[id.xy] = float4(transmittance, 1.0f);
}
```

ä»£ç å¾ˆç®€å•ï¼Œå°±æ˜¯éå† é«˜åº¦å’Œè§†è§’å¤©é¡¶è§’ï¼Œå¤ªé˜³æœå‘å·²çŸ¥ï¼Œå…¶ä»–éƒ½å¯ä»¥ç®—å‡ºæ¥ï¼ŒæŠŠé€å°„è®°å½•åˆ°Textureé‡Œé¢å°±è¡Œ

```
void UvToLutTransmittanceParams(AtmosphereParameters Atmosphere, out float viewHeight, out float viewZenithCosAngle, in float2 uv)
{
	//uv = float2(fromSubUvsToUnit(uv.x, TRANSMITTANCE_TEXTURE_WIDTH), fromSubUvsToUnit(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT)); // No real impact so off
	float x_mu = uv.x;
	float x_r = uv.y;

	float H = sqrt(Atmosphere.TopRadius * Atmosphere.TopRadius - Atmosphere.BottomRadius * Atmosphere.BottomRadius);
	float rho = H * x_r;
	viewHeight = sqrt(rho * rho + Atmosphere.BottomRadius * Atmosphere.BottomRadius);

	float d_min = Atmosphere.TopRadius - viewHeight;
	float d_max = rho + H;
	float d = d_min + x_mu * (d_max - d_min);
	viewZenithCosAngle = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * viewHeight * d);
	viewZenithCosAngle = clamp(viewZenithCosAngle, -1.0, 1.0);
}
```

![img](https://pic1.zhimg.com/80/v2-984776c1fed8512b928ecb6772f05d81_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

UvToLutTransmittanceParamsæŠŠrå’Œmuå‹ç¼©åˆ°ä¸€ä¸ªæœ€å¤§èŒƒå›´é‡Œé¢ç”¨æ¥æé«˜ç²¾åº¦

muè§†çº¿è§’åº¦é•¿åº¦èŒƒå›´å°±æ˜¯d_min å’Œ d_max 

 

 

```
float H = sqrt(Atmosphere.TopRadius * Atmosphere.TopRadius - Atmosphere.BottomRadius * Atmosphere.BottomRadius);
```

è¯¥Hå’Œå›¾ä¸­Hä¸æ˜¯ä¸€ä¸ªç‚¹ï¼Œè¡¨ç¤ºæŠŠç²¾åº¦å‹ç¼©åˆ°ä»¥ï¼ˆ0,0ï¼‰ä¸ºåŸç‚¹çš„Håæ ‡ç³»ä¸­

IntegrateScatteredLuminanceä¸­ï¼Œä¸»è¦è·å–medium.extinction * dt

```
viewZenithCosAngle = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * viewHeight * d);
...
MediumSampleRGB sampleMediumRGB(in float3 WorldPos, in AtmosphereParameters Atmosphere)
{
	const float viewHeight = length(WorldPos) - Atmosphere.BottomRadius;

	const float densityMie = exp(Atmosphere.MieDensityExpScale * viewHeight);
	const float densityRay = exp(Atmosphere.RayleighDensityExpScale * viewHeight);
	const float densityOzo = saturate(viewHeight < Atmosphere.AbsorptionDensity0LayerWidth ?
		Atmosphere.AbsorptionDensity0LinearTerm * viewHeight + Atmosphere.AbsorptionDensity0ConstantTerm :
		Atmosphere.AbsorptionDensity1LinearTerm * viewHeight + Atmosphere.AbsorptionDensity1ConstantTerm);

	MediumSampleRGB s;

	s.scatteringMie = densityMie * Atmosphere.MieScattering;
	s.absorptionMie = densityMie * Atmosphere.MieAbsorption;
	s.extinctionMie = densityMie * Atmosphere.MieExtinction;

	s.scatteringRay = densityRay * Atmosphere.RayleighScattering;
	s.absorptionRay = 0.0f;
	s.extinctionRay = s.scatteringRay + s.absorptionRay;

	s.scatteringOzo = 0.0;
	s.absorptionOzo = densityOzo * Atmosphere.AbsorptionExtinction;
	s.extinctionOzo = s.scatteringOzo + s.absorptionOzo;

	s.scattering = s.scatteringMie + s.scatteringRay + s.scatteringOzo;
	s.absorption = s.absorptionMie + s.absorptionRay + s.absorptionOzo;
	s.extinction = s.extinctionMie + s.extinctionRay + s.extinctionOzo;
	s.albedo = getAlbedo(s.scattering, s.extinction);

	return s;
}
...
MediumSampleRGB medium = sampleMediumRGB(P, Atmosphere);
const float3 SampleOpticalDepth = medium.extinction * dt;
const float3 SampleTransmittance = exp(-SampleOpticalDepth);
OpticalDepth += SampleOpticalDepth;
```

æœ€åå¾—åˆ°ä¸€å¼ LUT

![img](https://picx.zhimg.com/80/v2-cc79573046190b294a3d88a685288431_720w.png?source=d16d100b)



ç¼–è¾‘

é•¿ï¼šé€å°„ç‡ï¼Œå®½ï¼šé«˜åº¦

### MultipleScatteringLUT

```
numthreads(1, 1, 64)]
void NewMultiScattCS(uint3 ThreadId : SV_DispatchThreadID)
{
    float2 pixPos = float2(ThreadId.xy) + 0.5f;
    float2 uv = pixPos / MultiScatteringLUTRes;


    uv = float2(fromSubUvsToUnit(uv.x, MultiScatteringLUTRes), fromSubUvsToUnit(uv.y, MultiScatteringLUTRes));

    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    float cosSunZenithAngle = uv.x * 2.0 - 1.0;
    float3 sunDir = float3(sqrt(saturate(1.0 - cosSunZenithAngle * cosSunZenithAngle)), cosSunZenithAngle, 0.0);
    // We adjust again viewHeight according to PLANET_RADIUS_OFFSET to be in a valid range.
    float viewHeight = Atmosphere.BottomRadius + saturate(uv.y + PLANET_RADIUS_OFFSET) * (Atmosphere.TopRadius -
        Atmosphere.BottomRadius - PLANET_RADIUS_OFFSET);

    float3 WorldPos = float3(0.0f, viewHeight, 0.0f);
    float3 WorldDir = float3(0.0f, 1.0f, 0.0f);


    const bool ground = true;
    const float SampleCountIni = 20; // a minimum set of step is required for accuracy unfortunately
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = false;

    const float SphereSolidAngle = 4.0 * PI;
    const float IsotropicPhase = 1.0 / SphereSolidAngle;


    // Reference. Since there are many sample, it requires MULTI_SCATTERING_POWER_SERIE to be true for accuracy and to avoid divergences (see declaration for explanations)
    #define SQRTSAMPLECOUNT 8
    const float sqrtSample = float(SQRTSAMPLECOUNT);
    float i = 0.5f + float(ThreadId.z / SQRTSAMPLECOUNT);
    float j = 0.5f + float(ThreadId.z - float((ThreadId.z / SQRTSAMPLECOUNT) * SQRTSAMPLECOUNT));
    {
        float randA = i / sqrtSample;
        float randB = j / sqrtSample;
        float theta = 2.0f * PI * randA;
        float phi = acos(1.0f - 2.0f * randB);
        // uniform distribution https://mathworld.wolfram.com/SpherePointPicking.html
        //phi = PI * randB;						// bad non uniform
        float cosPhi = cos(phi);
        float sinPhi = sin(phi);
        float cosTheta = cos(theta);
        float sinTheta = sin(theta);
        WorldDir.x = cosTheta * sinPhi;
        WorldDir.y = sinTheta * sinPhi;
        WorldDir.z = cosPhi;
        SingleScatteringResult result = IntegrateScatteredLuminance(uv, WorldPos, WorldDir, sunDir, Atmosphere,
                                                                    ground, SampleCountIni, DepthBufferValue,
                                                                    VariableSampleCount, MieRayPhase);

        MultiScatAs1SharedMem[ThreadId.z] = result.MultiScatAs1 * SphereSolidAngle / (sqrtSample * sqrtSample);
        LSharedMem[ThreadId.z] = result.L * SphereSolidAngle / (sqrtSample * sqrtSample);
    }
    #undef SQRTSAMPLECOUNT

    GroupMemoryBarrierWithGroupSync();

    // 64 to 32
    if (ThreadId.z < 32)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 32];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 32];
    }
    GroupMemoryBarrierWithGroupSync();

    // 32 to 16
    if (ThreadId.z < 16)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 16];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 16];
    }
    GroupMemoryBarrierWithGroupSync();

    // 16 to 8 (16 is thread group min hardware size with intel, no sync required from there)
    if (ThreadId.z < 8)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 8];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 8];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 4)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 4];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 4];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 2)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 2];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 2];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z < 1)
    {
        MultiScatAs1SharedMem[ThreadId.z] += MultiScatAs1SharedMem[ThreadId.z + 1];
        LSharedMem[ThreadId.z] += LSharedMem[ThreadId.z + 1];
    }
    GroupMemoryBarrierWithGroupSync();
    if (ThreadId.z > 0)
        return;

    float3 MultiScatAs1 = MultiScatAs1SharedMem[0] * IsotropicPhase; // Equation 7 f_ms
    float3 InScatteredLuminance = LSharedMem[0] * IsotropicPhase; // Equation 5 L_2ndOrder

    // MultiScatAs1 represents the amount of luminance scattered as if the integral of scattered luminance over the sphere would be 1.
    //  - 1st order of scattering: one can ray-march a straight path as usual over the sphere. That is InScatteredLuminance.
    //  - 2nd order of scattering: the inscattered luminance is InScatteredLuminance at each of samples of fist order integration. Assuming a uniform phase function that is represented by MultiScatAs1,
    //  - 3nd order of scattering: the inscattered luminance is (InScatteredLuminance * MultiScatAs1 * MultiScatAs1)
    //  - etc.
    #if	MULTI_SCATTERING_POWER_SERIE==0
	float3 MultiScatAs1SQR = MultiScatAs1 * MultiScatAs1;
	float3 L = InScatteredLuminance * (1.0 + MultiScatAs1 + MultiScatAs1SQR + MultiScatAs1 * MultiScatAs1SQR + MultiScatAs1SQR * MultiScatAs1SQR);
    #else
    // For a serie, sum_{n=0}^{n=+inf} = 1 + r + r^2 + r^3 + ... + r^n = 1 / (1.0 - r), see https://en.wikipedia.org/wiki/Geometric_series 
    const float3 r = MultiScatAs1;
    const float3 SumOfAllMultiScatteringEventsContribution = 1.0f / (1.0 - r);
    float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution; // Equation 10 Psi_ms
    #endif

    OutputTexture[ThreadId.xy] = float4(MultipleScatteringFactor * L, 1.0f);
}
```

uv åˆ†åˆ«è¡¨ç¤º **é«˜åº¦ï¼ˆrï¼‰**å’Œ**å¤ªé˜³**å¤©é¡¶è§’ï¼ˆmu_sï¼‰

æ ¹æ®rç®—å‡ºWorldPosï¼Œæ ¹æ®mu_sç®—å‡ºsunDirï¼Œå‡åŒ€é‡‡æ ·çƒé¢64ä¸ªç‚¹ï¼Œç®—çƒé¢ç§¯åˆ†

```
        WorldDir.x = cosTheta * sinPhi;
        WorldDir.y = sinTheta * sinPhi;
        WorldDir.z = cosPhi;
```

å¦‚ä½•çƒé¢å‡åŒ€é‡‡æ ·ï¼Œå‚è€ƒ*https://mathworld.wolfram.com/SpherePointPicking.html*

MultipleScatteringå’ŒBruneton2017å¯¹æ¯”ï¼Œåšäº†ä¼˜åŒ–

```
    const float SphereSolidAngle = 4.0 * PI;
    const float IsotropicPhase = 1.0 / SphereSolidAngle;
```

1.å„é¡¹åŒæ€§

2.é‡‡æ ·å‘¨å›´ç‚¹çš„å…‰èƒ½é‡ç›¸åŒ

ç›¸å½“äºä¸€ä¸ªç³»æ•°è¡°å‡

```
    float3 MultiScatAs1 = MultiScatAs1SharedMem[0] * IsotropicPhase; // Equation 7 f_ms
    float3 InScatteredLuminance = LSharedMem[0] * IsotropicPhase; // Equation 5 L_2ndOrder
```

æŠŠç»“æœåŠ ä¸€èµ·ï¼ŒGroupMemoryBarrierWithGroupSyncæ˜¯åšä»€ä¹ˆçš„ï¼Œå¯ä»¥å‚è€ƒ

![img](https://picx.zhimg.com/80/v2-d489b96c126a5c3f079ccf87a97015dc_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

IntegrateScatteredLuminanceé‡Œé¢ç§¯åˆ†è¿ç®—ç”¨äº†å¯’éœœå¼•æ“çš„æ–¹æ³•

```
        float3 MS = medium.scattering * 1;
        float3 MSint = (MS - MS * SampleTransmittance) / medium.extinction;
        result.MultiScatAs1 += throughput * MSint;
        ...
        float3 Sint = (S - S * SampleTransmittance) / medium.extinction; // integrate along the current step segment 
        L += throughput * Sint; // accumulate and also take into account the transmittance from previous steps
        throughput *= SampleTransmittance;
```

![img](https://picx.zhimg.com/80/v2-9fe705d024e85d3275374b8661be9b89_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

### Sky-ViewLUT 

```
[numthreads(8, 8, 1)]
void IntergalSkyViewLutPS(uint3 id: SV_DispatchThreadID)
{
    float2 pixPos = id.xy + 0.5f;
    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    float3 WorldPos = camera + float3(0, Atmosphere.BottomRadius, 0);
    float2 uv = pixPos / float2(192.0, 108.0);
    float viewHeight = length(WorldPos);
    float viewZenithCosAngle;
    float lightViewCosAngle;
    UvToSkyViewLutParams(Atmosphere, viewZenithCosAngle, lightViewCosAngle, viewHeight, uv);


    float3 SunDir;
    {
        float3 UpVector = WorldPos / viewHeight;
        float sunZenithCosAngle = dot(UpVector, sun_direction);
        SunDir = normalize(float3(sqrt(1.0 - sunZenithCosAngle * sunZenithCosAngle), sunZenithCosAngle, 0.0));
    }
    
    
    WorldPos = float3(0.0f, viewHeight, 0.0f);
    
    float viewZenithSinAngle = sqrt(1 - viewZenithCosAngle * viewZenithCosAngle);
    float3 WorldDir = float3(viewZenithSinAngle * lightViewCosAngle,
                             viewZenithCosAngle,
                             viewZenithSinAngle * sqrt(1.0 - lightViewCosAngle * lightViewCosAngle));


    // Move to top atmospehre
    if (!MoveToTopAtmosphere(WorldPos, WorldDir, Atmosphere.TopRadius))
    {
        // Ray is not intersecting the atmosphere
        _SkyViewLUT[id.xy] = float3(0, 0, 0);
        return;
    }

    const bool ground = false;
    const float SampleCountIni = 30;
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = true;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(uv, WorldPos, WorldDir, SunDir, Atmosphere, ground,
                                                            SampleCountIni, DepthBufferValue, VariableSampleCount,
                                                            MieRayPhase);
     _SkyViewLUT[id.xy] = ss.L;
}
```

viewZenithCosAngleå’ŒlightViewCosAngleå–å€¼èŒƒå›´[1,-1]è§’åº¦0-90åº¦

```
 UvToSkyViewLutParams(Atmosphere, viewZenithCosAngle, lightViewCosAngle, viewHeight, uv);
```

WorldPos UpVector WorldDir è·ŸUEçš„åŒºåˆ«æ”¹äº†upæœå‘ï¼ŒUEæ˜¯zæœä¸Šï¼Œunityæ˜¯yæœä¸Š

![img](https://picx.zhimg.com/80/v2-99d846b47f7238ae6df0af0a497d542a_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

### AerialPerspectiveLUT

```
[numthreads(8, 8, 1)]
void IntergalCameraVolumeLUT(uint3 id: SV_DispatchThreadID)
{
    float2 pixPos = id.xy + 0.5f;
    float w, h, d;
    _CameraVolumeLUT.GetDimensions(w, h, d);
    AtmosphereParameters Atmosphere = GetAtmosphereParameters();
    float2 uv = pixPos / float2(w, h);
    float3 ClipSpace = float3(uv * float2(2.0, -2.0) - float2(1.0, -1.0), 0.5);
    float4 HViewPos = mul(gSkyInvProjMat, float4(ClipSpace, 1.0));
    float3 WorldDir = normalize(mul((float3x3)gSkyInvViewMat, HViewPos.xyz / HViewPos.w));

    float earthR = Atmosphere.BottomRadius;
    float3 camPos = camera + float3(0, earthR, 0);
    float3 SunDir = sun_direction;
    
    float Slice = ((id.z + 0.5f) / AP_SLICE_COUNT);
    Slice *= Slice; // squared distribution
    Slice *= AP_SLICE_COUNT;

    float3 WorldPos = camPos;

    // Compute position from froxel information
    float tMax = AerialPerspectiveSliceToDepth(Slice);
    float3 newWorldPos = WorldPos + tMax * WorldDir;

    // If the voxel is under the ground, make sure to offset it out on the ground.
    float viewHeight = length(newWorldPos);
    if (viewHeight <= (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET))
    {
        // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
        newWorldPos = normalize(newWorldPos) * (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET + 0.001f);
        WorldDir = normalize(newWorldPos - camPos);
        tMax = length(newWorldPos - camPos);
    }
    float tMaxMax = tMax;

    const bool ground = false;
    const float SampleCountIni = max(1.0, float(id.z + 1.0) * 2.0f);
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(uv, WorldPos, WorldDir, SunDir, Atmosphere, ground,
                                                            SampleCountIni, DepthBufferValue, VariableSampleCount,
                                                            MieRayPhase, tMaxMax);


    const float Transmittance = dot(ss.Transmittance, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
    _CameraVolumeLUT[id] = float4(ss.L, 1.0 - Transmittance);
}
```

![img](https://picx.zhimg.com/80/v2-2bc775b842f2970cf79bfafbe32165ef_720w.png?source=d16d100b)



ç¼–è¾‘

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

```
#define AP_SLICE_COUNT 32.0f åˆ‡ç‰‡æ•°
#define AP_KM_PER_SLICE 3.0f  ä¸€åˆ‡ç‰‡åŒ…å«å¤šå°‘å…¬é‡Œ
...
float tMax = AerialPerspectiveSliceToDepth(Slice); æ ¹æ®åˆ‡ç‰‡è¿˜åŸå°„çº¿æœ€è¿œå¯åˆ°è¾¾è·ç¦»
```

![img](https://picx.zhimg.com/80/v2-9009a9eca8f18d212d384f39e97bbddc_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

å·ç§°1mså¯ä»¥åœ¨6sä¸Šæ¸²æŸ“å®Œæˆ4ä¸ªlut

![img](https://picx.zhimg.com/80/v2-b92ab3bbb4400433115c380a20c6c941_720w.png?source=d16d100b)



ç¼–è¾‘åˆ‡æ¢ä¸ºå±…ä¸­

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

æœ€ååœ¨åå¤„ç†åŠ ä¸ŠAerialPerspectiveå’Œshadowçš„å¤„ç†å³å¯

ç»“å°¾ï¼š

[SlightlyMad](https://github.com/SlightlyMad/AtmosphericScattering)ï¼ŒS[ebh](https://github.com/sebh/UnrealEngineSkyAtmosphere)ï¼ŒB[runeton](https://github.com/ebruneton/precomputed_atmospheric_scattering) çš„å¤§æ°”æ•£å°„æ•ˆæœå®ç°å„ä¸ç›¸åŒï¼Œéœ€è¦æ ¹æ®å®é™…é¡¹ç›®éœ€æ±‚ä¿®æ”¹æ•ˆæœ

åœ¨ç§»åŠ¨ç«¯æ€§èƒ½éœ€è¦åšä¸€ä¸ªå–èˆï¼Œæ¯”å¦‚åŸç¥çš„å¤©ç©ºä¸æ˜¯å®Œå…¨åŸºäºç‰©ç†å¤§æ°”æ¸²æŸ“ï¼Œæ•ˆæœä¹Ÿæ˜¯å¾ˆæ£’çš„

æœ¬äººèƒ½åŠ›æœ‰é™ï¼Œå¯èƒ½æœ‰ä¸€äº›é”™è¯¯ï¼Œè¯·å¤šå¤šæŒ‡æ•™

æœºç¿»è¯‘äº†2ç¯‡è®ºæ–‡ï¼Œéœ€è¦è‡ªå–

![img](https://pica.zhimg.com/80/v2-e90ef968a309b4bd86eea39588235c8a_720w.png?source=d16d100b)



ç¼–è¾‘

æ·»åŠ å›¾ç‰‡æ³¨é‡Šï¼Œä¸è¶…è¿‡ 140 å­—ï¼ˆå¯é€‰ï¼‰

é¡¹ç›®æºç 

å‚è€ƒèµ„æ–™ï¼š

[01.æ¸¸æˆå¼•æ“å¯¼è®º | GAMES104-ç°ä»£æ¸¸æˆå¼•æ“ï¼šä»å…¥é—¨åˆ°å®è·µ_å“”å“©å“”å“©_bilibili](https://www.bilibili.com/video/BV1oU4y1R7Km/?spm_id_from=333.337.top_right_bar_window_default_collection.content.click&vd_source=701515b74d4706506279918ac2d96c1e)

[GAMES101-ç°ä»£è®¡ç®—æœºå›¾å½¢å­¦å…¥é—¨-é—«ä»¤çª_å“”å“©å“”å“©_bilibili](https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.999.0.0&vd_source=701515b74d4706506279918ac2d96c1e)

https://github.com/sebh/UnrealEngineSkyAtmosphere

https://github.com/SlightlyMad/AtmosphericScattering

https://github.com/ebruneton/precomputed_atmospheric_scattering

https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/

https://sebh.github.io/publications/egsr2020.pdf